### 用不到 200 行的 GO 语言编写您自己的区块链

世界上几乎每个开发者都听说过区块链，但大多数仍然不知道它的工作原理。他们可能仅仅是因为比特币才知道它，又或者是因为他们听说过智能合约之类的东西。这篇文章试图通过帮助您用 Go 编写自己的简单区块链，使用少于 200 行代码来揭开区块链的神秘面纱！到本教程结束时，您将能够编写并在本地运行您自己的区块链，以及在 Web 浏览器中查看它。
还有什么比通过创建自己的区块链来了解区块链更好的方法呢？

##### 您将能够做什么

- 创建您自己的区块链
- 了解 hash 如何维护区块链的完整性
- 了解如何添加新块
- 了解当多个节点生成块时，tiebreakers 如何解决
- 在 web 浏览器中查看区块链
- 写新的块
- 获取区块链的基础知识，以便您可以决定您的旅程将从这里走向何处！

##### 您不能做的事

为了保持本文的简单性，我们不会处理更高级的共识概念，比如工作证明和利害关系证明。为了让您查看您的区块链和区块的添加，我们将模拟网络交互，但网络广播作为文章的深度将被保留。

##### 准备工作

既然我们决定用 Go 编写代码，我们假设您已经有了一些 Go 方面的经验，在安装并配置 Go 之后，我们还需要获取以下软件包：

go get github.com/davecgh/go-spew/spew

Spew 允许我们在控制台中查看格式清晰的 structs 和 slices，您值得拥有。

go get github.com/gorilla/mux

Gorilla/mux 是编写 Web 程序处理的常用包。我们将会使用它。

go get github.com/joho/godotenv

Gotdotenv 允许我们从根目录中读取 .env 文件，这样就不必对 HTTP 端口之类的内容进行硬编码。我们也需要这个。

我们在根目录中创建 .env 文件，定义为 http 请求提供服务的端口。只需要该文件添加一行：

ADDR=8080

创建 main.go 文件。从现在开始，所有的内容都会写进这个文件中，并且将用少于 200 代码进行编码。

##### 导入

这是我们需要导入的以及包声明，我们把它们写入 main.go

![](https://i.imgur.com/KxlxmRU.png)

##### 数据模型

我们将定义组成区块链的每个块的 struct 。别担心，我们会在一分钟内结束所有这些字段的含义。

![](https://i.imgur.com/zUk0a47.png)

每个 Block  都包含将被写入区块链的数据，并表示当您获取脉搏率时的每一种情况（还记得您在文章的开头就这样做了么？）。

- Index 是数据记录在区块链中的位置
- Timestamp 是自动确定写入数据的时间
- BPM 每分钟节拍数，是您的脉搏率
- Hash 是表示此数据记录的 SHA256 标识符
- PrevHash 是链中上一条记录的 SHA256 标识符

我们也对区块链本身建模，它只是 Block 中的 slice:



![](https://i.imgur.com/55S897J.png)




那么散列如何适合于块和区块链呢？我们使用散列表来识别和保持块的正确顺序。通过确保每个 Block 中的 PrevHash 与前面 Block 块中的 Hash 相同，我们知道组成链的块的正确顺序。

![](https://i.imgur.com/4dGrApi.png)


##### 散列和生成新块
那我们为什么需要散列呢？我们散列数据的两个主要原因：

- 为了节省空间。散列从块上的所有数据派生。在我们的示例中，我们只有几个数据点，但是假设我们有来自数百、数千或者数百万以前的数据块的数据。将数据散列到单个 SHA256 字符串或散列这些散列表中要比一遍又一遍地复制前面块中的所有数据高效得多。
- 保护区块链的完整性。通过存储前面的散列，就像我们在上面的图中所做的那样，我们能够确保区块链中的块是按正确的顺序排列的。如果恶意的一方试图操纵数据（例如，改变我们的心率来确定人寿保险的价格），散列将迅速改变，链将“断裂”，每个人都会知道也不再信任这个恶意链。

让我们编写一个函数，该函数接受 Block 数据并创建 i 的 SHA256 散列值。

![](https://i.imgur.com/RfZwZlP.png)


这个 calculateHash 函数将 Block 的 Index、Timestamp、BPM，我们提供块的 PrevHash 链接为一个参数，并以字符串的形式返回 SHA256 散列。现在我们可以用一个新的 generateBlock 函数来生成一个包含我们所需的所有元素的新块。我们需要提供它前面的块，以便我们可以得到它的散列以及在 BPM 中的脉搏率。不要担心传入 BPM int 参数。我们稍后再讨论这个问题。

![](https://i.imgur.com/r0diSMm.png)

注意当前时间使用 time.Now() 自动写入块中的。还请注意，我们之前的 calculateHash 函数是被调用的。从上一个块的散列复制到 PrevHash。Index 从上一个块的索引中递增。
##### 块校验
我们需要编写一些函数来确保这些块没有被篡改。我们还通过检查 Index 来实现这一点，以确保它们按预期的速度递增。我们还将检查以确保我们的 PrevHash 与前一个块的 Hash 相同。最后，我们希望通过在当前块上再次运行 calculateHash 函数来重新检查当前块的散列。让我们编写一个 isBlockValid  函数，它执行所有这些操作并返回一个 bool。如果它通过了我们所有的检查，它就会返回  true：

![](https://i.imgur.com/Z6cu7uY.png)

如果我们遇到这样一个问题，即区块链生态系统的两个节点都向它们的链添加了区块，并且我们都收到了它们。我们选择哪一个作为真理的来源？我们选择最长的链条。这是一个经典的区块链问题，与邪恶的演员没有任何关系。

两个有意义的节点可能只是具有不同的链长，因此很自然地，较长的节点将是最新的，并且拥有最新的块。因此，让我们确保我们正在接受的新链要比我们现有的链长。如果是，我们可以用具有新块的新链覆盖我们的链。

![](https://i.imgur.com/3y4WRki.png)

为了实现这一点，我们简单地比较了链片的长度：

![](https://i.imgur.com/7KNqcpb.png)

如果您已经坚持做到这里，就鼓励一下自己！基本上，我们已经用我们需要的各种函数编写了区块链的内部结构。

现在，我们想要一个方便的方式来查看我们的区块链，并写入它，理想情况下是我们可以在一个网络浏览器显示我们的朋友！


##### Web 服务器

我们假设您已经熟悉 Web 服务器的工作方式，并有一些将它们连接到 Go 中的经验。我们现在就带你走一遍这个流程。

我们将使用之前下载的 Gorilla/mux 包来为我们完成繁重的任务。在稍后调用的 run 函数中创建服务器。